plot(d12lnserie-d12lnserie.lin)
dev.off()
plot(d12lnserie.lin)
d12lnserie.lin.EE <- d12lnserie.lin - EasterEf
plot(d12lnserie.lin.EE)
boxplot(d12lnserie.lin.EE~floor(time(d12lnserie.lin.EE)))
lnm=apply(matrix(d12lnserie.lin.EE,nr=12),2,mean) # taking the sum of the colums
lnv=apply(matrix(d12lnserie.lin.EE,nr=12),2,var)
plot(lnm,lnv,xlab="Anual mean",ylab="anual variance",main="serie")
abline(lm(lnv~lnm),col=2,lty=3,lwd=2)
d1d12lnserie.lin.EE=diff(d12lnserie.lin.EE,1)
plot(d12lnserie.lin.EE)
abline(h=0)
abline(h=mean(d12lnserie.lin.EE), col=2)
var(d12lnserie.lin.EE)
var(d1d12lnserie.lin.EE)
png('acf_pacf_outliers.png')
par(mfrow=c(1,2), mar=c(5,4,4,5))
acf(d12lnserie.lin.EE,ylim=c(-1,1),col=c(2,rep(1,11)),lwd=2,lag.max=72)
pacf(d12lnserie.lin.EE,ylim=c(-1,1),col=c(rep(1,11),2),lwd=2,lag.max=72)
par(mfrow=c(1,1))
dev.off()
#old model
(mod1EE.lin=arima(d12lnserie.lin,order=c(2,0,0),seasonal=list(order=c(0,0,1),period=12),xreg=d12lnwEast))
#models sugested form Acf Pacf
(mod1EE.lin=arima(d12lnserie.lin,order=c(4,0,0),seasonal=list(order=c(0,0,1),period=12),xreg=d12lnwEast))
(mod1EE.lin=arima(d12lnserie.lin,order=c(4,0,0),seasonal=list(order=c(1,0,0),period=12),xreg=d12lnwEast))
(mod1EE.lin=arima(d12lnserie.lin,order=c(0,0,5),seasonal=list(order=c(1,0,0),period=12),xreg=d12lnwEast))
(mod1EE.lin=arima(d12lnserie.lin,order=c(0,0,5),seasonal=list(order=c(0,0,1),period=12),xreg=d12lnwEast))
#Model using transformed data and the best of the above parameters
(mod1EE.lin=arima(d12lnserie.lin.EE,order=c(4,0,0),seasonal=list(order=c(0,0,1),period=12))) #best
(mod1EE.lin_1=arima(d12lnserie.lin,order=c(4,0,0),seasonal=list(order=c(0,0,1),period=12),xreg=d12lnwEast))
(mod1EE.lin_2=arima(d12lnserie.lin.EE,order=c(4,0,0),seasonal=list(order=c(0,0,1),period=12)))
#Linearized (free of CEs and outliers) series in log-scale
plot(d12lnserie-d12lnserie.lin.EE)             #Profile of effects
dades=d12lnserie.lin.EE  #stationary series d1d12lnserieEC.lin; free of CEs and outliers
model=(mod1EE.lin_2)                # fitted ARIMA model
validation(model,dades)
last_date=c(2018,12)
d12lnserie.lin1=window(d12lnserie.lin.EE,end=last_date+c(1,0))
d12lnserie.lin2=window(d12lnserie.lin.EE,end=last_date)
#Fit the model to the complete series: lnserie.lin1
(modEC.lin=arima(d12lnserie.lin1,order=c(4,0,0),seasonal=list(order=c(0,0,1),period=12)))
#Fit the model to the subset series (without 2018 data): lnserie.lin2
(modEC.lin2=arima(d12lnserie.lin2,order=c(4,0,0),seasonal=list(order=c(0,0,1),period=12)))
######### Out of sample prediction: reserve 2019 data
pred=predict(modEC.lin2,n.ahead=12,start=c(last_date[1]+1,1))
pred_with_easter <- pred$pred + coef(mod1EE_2)["wEast.2"]*Weaster(c(last_date[1]+1, 1, 12))
wLS=sum(modEE.atip$atip[modEE.atip$atip$type_detected=="LS  " & modEE.atip$atip$Obs<=length(serie)-12,3]) # 3 is the indec for coef
pred_with_easter_and_outliers<- pred_with_easter+ rep(wLS, length(pred$pred))
pr<-window(diffinv(pred_with_easter_and_outliers,12,xi=window(lnserie,start=last_date+c(-1,1),end=last_date+c(0,0))),start=last_date)
se<-ts(c(0,pred$se),start=last_date,freq=12)               #Standard errors for puntual predictions
##Prediction Intervals (back transformed to original scale using exp-function)
tl<-ts(exp(pr-1.96*se),start=last_date,freq=12)
tu<-ts(exp(pr+1.96*se),start=last_date,freq=12)
pr<-ts(exp(pr),start=last_date,freq=12)
#Plot of the original airbcn series (thousands) and out-of-sample predictions
ts.plot(serie,tl,tu,pr,lty=c(1,2,2,1),col=c(1,4,4,2),xlim=last_date[1]+c(-3,2),type="o",main="Model ARIMA(4,0,0)(0,0,1)_12+Easter + outliers")
abline(v=(last_date[1]-3):(last_date[1]+2),lty=3,col=4)
obs=window(serie,start=last_date)
(mod.EQM3=sqrt(sum(((obs-pr)/obs)^2)/12))
(mod.EAM3=sum(abs(obs-pr)/obs)/12)
pred=predict(modEC.lin,n.ahead=12)
pred_with_easter<- pred$pred + coef(mod1EE_2)["wEast.2"]*Weaster(c(last_date[1]+2, 1, 12))
wLS=sum(modEE.atip$atip[modEE.atip$atip$type_detected=="LS",3]) # 3 is the indec for coef
pred_with_easter_and_outliers<- pred_with_easter+ rep(wLS, length(pred$pred))
pr<-window(diffinv((pred_with_easter_and_outliers),12,xi=window(lnserie,start=last_date+c(0,1),end=last_date+c(1,0))),start=last_date+c(1,0))
model<-modEC.lin$model
varZ<-modEC.lin$sigma
ma<-ARMAtoMA(ar=modEC.lin$phi,ma=modEC.lin$theta,lag.max=11)
se<-(c(0,sqrt((cumsum(c(1,ma))^2)*varZ)))
#Intervals
tl3<-ts(exp(pr-1.96*(se)),start=last_date+c(1,0),freq=12)
tu3<-ts(exp(pr+1.96*(se)),start=last_date+c(1,0),freq=12)
pr3<-ts(exp(pr),start=last_date+c(1,0),freq=12)
ts.plot(serie,tl1,tu1,pr1,lty=c(1,2,2,1),col=c(1,4,4,2),xlim=c(2016,2021),type="o",main=paste("Model ARIMA(",paste(pdq,collapse=","),")(",paste(PDQ,collapse=","),")12",sep=""))
abline(v=2016:2021,lty=3,col=4)
(preview3=window(cbind(tl3,pr3,tu3),start=last_date+c(1,0)))
#cbind(previs1,previs2,previs3)
par(mfrow=c(3,1),mar=c(3,3,1,1))
ts.plot(serie,preview1,lty=c(1,2,1,2),col=c(1,4,2,4),xlim=c(2018,2021),type="o",main="Model ARIMA(2,0,0)(0,0,1)_12")
abline(v=2017:2021,lty=3,col=4,ylim=c(15,280))
ts.plot(serie,preview2,lty=c(1,2,1,2),col=c(1,4,2,4),xlim=c(2018,2021),type="o",main="Model ARIMA(2,0,0)(0,0,1)_12 + Easter effect")
abline(v=2017:2021,lty=3,col=4,ylim=c(15,280))
ts.plot(serie,preview3,lty=c(1,2,1,2),col=c(1,4,2,4),xlim=c(2018,2021),type="o",main="Model ARIMA(4,0,0)(0,0,1)_12 + Easter effect+Atip")
abline(v=2017:2021,lty=3,col=4,ylim=c(15,280))
par(mfrow=c(1,1))
result=data.frame(
par=c(length(coef(mod)),length(coef(modEE))+ 1,length(coef(mod1EE.lin))+nrow(modEE.atip$atip)),
Sigma2Z=c(mod$sigma2,modEE$sigma2,mod1EE.lin$sigma2),
AIC=c(AIC(mod),AIC(mod1EE) +2,AIC(mod1EE.lin)+2*(nrow(modEE.atip$atip)+1)),
BIC=c(BIC(mod),BIC(modEE)+ log(length(serie)-12)*2,BIC(mod1EE.lin)+log(length(serie)-12)*(nrow(modEE.atip$atip)+2)), #Have to manully add penalty for adding parameters regarding easter and outlier effects
RMSPE=c(mod.EQM1,mod.EQM2,mod.EQM3),
MAPE=c(mod.EAM1,mod.EAM2,mod.EAM3),
meanLength=c(sum(preview1[,3]-preview1[,1]),sum(preview2[,3]-preview2[,1]),sum(preview3[,3]-preview3[,1]))/12)
row.names(result)=c("Model ARIMA(2,0,0)(0,0,1)_12","Model ARIMA(2,0,0)(0,0,1)_12+CEs","Model ARIMA(4,0,0)(0,0,1)_12+CEs+Outliers")
result
png('mod.png')
(mod=arima(d12lnserie,order=c(2,0,0),seasonal=list(order=c(0,0,1),period=12)))
dev.off()
abs(mod$coef/sqrt(diag(mod$var.coef)))
BIC.ARIMA <- BIC(mod)
cat("BIC.ARIMA=", BIC.ARIMA)
(mod_1=arima(d12lnserie,order=c(2,0,0),seasonal=list(order=c(1,0,0),period=12)))
abs(mod_1$coef/sqrt(diag(mod_1$var.coef)))
BIC.ARIMA <- BIC(mod_1)
cat("BIC.ARIMA=", BIC.ARIMA)
(mod_2=arima(d12lnserie,order=c(0,0,3),seasonal=list(order=c(1,0,0),period=12)))
abs(mod_2$coef/sqrt(diag(mod_2$var.coef)))
BIC.ARIMA <- BIC(mod_2)
cat("BIC.ARIMA=", BIC.ARIMA)
(mod_3=arima(d1d12lnserie,order=c(0,0,3),seasonal=list(order=c(1,0,0),period=12)))
abs(mod_3$coef/sqrt(diag(mod_3$var.coef)))
BIC.ARIMA <- BIC(mod_3)
cat("BIC.ARIMA=", BIC.ARIMA)
knitr::opts_chunk$set(echo = TRUE)
library(rstan)
library(ggplot2)
library(tidyr)
data<- read.csv("data/Death_week_2_17_netherland.csv", sep = ";")
data_2 <- read.csv("data/England_Wales_weekly.csv",sep = ";")
data_3 <- read.csv("data/italy_week_deaths.csv", sep = ",")
data<- read.csv("data/Death_week_2_17_netherland.csv", sep = ";")
data_2 <- read.csv("data/England_Wales_weekly.csv",sep = ";")
data_3 <- read.csv("data/italy_week_deaths.csv", sep = ",")
mean <- as.vector(as.matrix(data)[,6])
data_2020<-as.vector(as.matrix(data)[,5])
mean_england <- as.vector(as.matrix(data_2)[,12])
england_2020 <- as.vector(as.matrix(data_2)[,13])
mean_italy <- as.vector(as.matrix(data_3)[,9])
italy_2020 <- as.vector(as.matrix(data_3)[,8])
mean_england <- as.vector(as.matrix(data_2)[,12])
england_2020 <- as.vector(as.matrix(data_2)[,13])
mean_italy <- as.vector(as.matrix(data_3)[,9])
italy_2020 <- as.vector(as.matrix(data_3)[,8])
N_netherland <- length(mean)
data_list_netherland <- list(
N = N_netherland,
E = mean,
O = data_2020,
mu1 = 0,
mu2 = 0,
sigma1 = 100,
sigma2 = 10
)
N_england <- length(mean_england)
data_list_england <- list(
N = N_england,
E = mean_england,
O = england_2020,
mu1 = 0,
mu2 = 0,
sigma1 = 100,
sigma2 = 10
)
N_italy <- length(mean_italy)
data_list_italy <- list(
N = N_italy,
E = mean_italy,
O = italy_2020,
mu1 = 0,
mu2 = 0,
sigma1 = 100,
sigma2 = 10
)
death_netherland <- stan("test_spatial.stan", iter = 2000, chains = 4,
data = data_list_netherland, seed = 1)
death_england <- stan("test_spatial.stan", iter = 2000, chains = 4,
data = data_list_england, seed = 1)
death_italy <- stan("test_spatial.stan", iter = 2000, chains = 4,
data = data_list_italy, seed = 1)
library(keras)
#### Data
mnist <- dataset_mnist()
x_train <- mnist$train$x
y_train <- mnist$train$y
x_test <- mnist$test$x
y_test <- mnist$test$y
# reshape
dim(x_train) <- c(nrow(x_train), 784)
dim(x_test) <- c(nrow(x_test), 784)
cifra <- c(0:9)
x_train_cifra<-x_train[which(y_train %in% cifra),]
y_train_cifra<-y_train[which(y_train %in% cifra)]
x_test_cifra<-x_test[which(y_test %in% cifra),]
y_test_cifra<-y_test[which(y_test %in% cifra)]
dim(x_train_cifra)
length(y_train_cifra)
dim(x_test_cifra)
length(y_test_cifra)
unique(y_train_cifra)
unique(y_test_cifra)
x_train_cifra <- x_train_cifra / 255
x_test_cifra <- x_test_cifra / 255
model_enc <- keras_model_sequential()
model_enc %>%
layer_dense(units = 128, activation = "relu", input_shape =  ncol(x_train)) %>%
layer_dense(units = 64, activation = "relu") %>%
layer_dense(units = 32, activation = "relu")
summary(model_enc)
model_dec <- keras_model_sequential()
model_dec %>%
layer_dense(units = 64, activation = "relu", input_shape =  c(32)) %>%
layer_dense(units = 128, activation = "relu") %>%
layer_dense(units = ncol(x_train), activation = "relu")
summary(model_dec)
model<-keras_model_sequential()
model %>%model_enc%>%model_dec
summary(model)
model %>% compile(
loss = "mean_squared_error",
#optimizer = optimizer_rmsprop(),
optimizer = "adam",
metrics = c("mean_squared_error")
)
history <- model %>% fit(
x= x_train_cifra, y = x_train_cifra,   # Autoencoder
epochs = 15, batch_size = 128,
validation_split = 0.2
)
# Autoencoder
output_cifra<-predict(model,x_test_cifra)
dim(output_cifra)
# From input to encoder
enc_output_cifra<-predict(model_enc,x_test_cifra)
dim(enc_output_cifra)
# From encoder to decoder
dec_output_cifra<-predict(model_dec,enc_output_cifra)
dim(dec_output_cifra)
idx<-1
#x_test_cifra[idx,]
im<-matrix(x_test_cifra[idx,], nrow=28, ncol=28)
image(1:28, 1:28, im, col=gray((0:255)/255))
#output_cifra[idx,]
im<-matrix(output_cifra[idx,], nrow=28, ncol=28)
image(1:28, 1:28, im, col=gray((0:255)/255))
#dec_output_cifra[idx,]
im<-matrix(dec_output_cifra[idx,], nrow=28, ncol=28)
image(1:28, 1:28, im, col=gray((0:255)/255))
idx<-1
#x_test_cifra[idx,]
im<-matrix(x_test_cifra[idx,], nrow=28, ncol=28)
image(1:28, 1:28, im, col=gray((0:255)/255))
#output_cifra[idx,]
im<-matrix(output_cifra[idx,], nrow=28, ncol=28)
image(1:28, 1:28, im, col=gray((0:255)/255))
#dec_output_cifra[idx,]
im<-matrix(dec_output_cifra[idx,], nrow=28, ncol=28)
image(1:28, 1:28, im, col=gray((0:255)/255))
# Encoder results
im<-matrix(enc_output_cifra[idx,], nrow=8, ncol=4)
image(1:8, 1:4, im, col=gray((0:255)/255))
save(enc_output_cifra, y_test_cifra, file=paste0("Encod_", paste(cifra, collapse = ""), ".RData"))
library(keras)
#### Data
mnist <- dataset_mnist()
x_train <- mnist$train$x
y_train <- mnist$train$y
x_test <- mnist$test$x
y_test <- mnist$test$y
cifra <- c(0:9)
x_train_cifra<-x_train[which(y_train %in% cifra),,]
y_train_cifra<-y_train[which(y_train %in% cifra)]
x_test_cifra<-x_test[which(y_test %in% cifra),,]
y_test_cifra<-y_test[which(y_test %in% cifra)]
dim(x_train_cifra)
length(y_train_cifra)
dim(x_test_cifra)
length(y_test_cifra)
unique(y_train_cifra)
unique(y_test_cifra)
# Input image dimensions
img_rows <- 28  # dim(x_train_cifra)[2]
img_cols <- 28  # dim(x_train_cifra)[3]
# Redefine dimension of train/test inputs
x_train_cifra <- array_reshape(x_train_cifra, c(nrow(x_train_cifra), img_rows, img_cols, 1))
x_test_cifra <- array_reshape(x_test_cifra, c(nrow(x_test_cifra), img_rows, img_cols, 1))
input_dim <- c(img_rows, img_cols, 1)
x_train_cifra <- x_train_cifra / 255
x_test_cifra <- x_test_cifra / 255
model_enc <- keras_model_sequential()
model_enc %>%
layer_conv_2d(filters = 16, kernel_size = c(3,3),
activation = "relu", padding = "same",
input_shape = input_dim)  %>%
layer_max_pooling_2d(pool_size = c(2,2), padding = "same")  %>%
layer_conv_2d(filters = 8, kernel_size = c(3,3),
activation = "relu", padding = "same") %>%
layer_max_pooling_2d(pool_size = c(2,2), padding = "same")  %>%
layer_conv_2d(filters = 8, kernel_size = c(3,3),
activation = "relu", padding = "same") %>%
layer_max_pooling_2d(pool_size = c(2,2), padding = "same")
summary(model_enc)
model_dec <- keras_model_sequential()
model_dec %>%
layer_conv_2d(filters = 8, kernel_size = c(3,3),
activation = "relu", padding = "same",
input_shape = c(4, 4, 8))  %>%
layer_upsampling_2d(size = c(2,2))  %>%
layer_conv_2d(filters = 8, kernel_size = c(3,3),
activation = "relu", padding = "same")  %>%
layer_upsampling_2d(size = c(2,2))  %>%
# Important: no padding
layer_conv_2d(filters = 1, kernel_size = c(3,3),
activation = "relu")  %>%
layer_upsampling_2d(size = c(2,2))
summary(model_dec)
model<-keras_model_sequential()
model %>%model_enc%>%model_dec
summary(model)
model %>% compile(
loss = "mean_squared_error",
#optimizer = optimizer_rmsprop(),
optimizer = "adam",
metrics = c("mean_squared_error")
)
history <- model %>% fit(
x= x_train_cifra, y = x_train_cifra,   # Autoencoder
epochs = 5, batch_size = 128,
suffle = TRUE,
validation_split = 0.2
#  validation_data = list(x_test_cifra,x_test_cifra)
)
setwd("~/Documents/Utveksling/Stat_l√¶r/Module_5/Labs AE  CAE-20200511")
# Autoencoder
output_cifra<-predict(model,x_test_cifra)
dim(output_cifra)
# From input to encoder
enc_output_cifra<-predict(model_enc,x_test_cifra)
dim(enc_output_cifra)
# From encoder to decoder
dec_output_cifra<-predict(model_dec,enc_output_cifra)
dim(dec_output_cifra)
idx<-1
#x_test_cifra[idx,,,1]
im<-matrix(x_test_cifra[idx,,,1], nrow=28, ncol=28)
image(1:28, 1:28, im, col=gray((0:255)/255))
#output_cifra[idx,,,1]
im<-matrix(output_cifra[idx,,,1], nrow=28, ncol=28)
image(1:28, 1:28, im, col=gray((0:255)/255))
#dec_output_cifra[idx,,,1]
im<-matrix(dec_output_cifra[idx,,,1], nrow=28, ncol=28)
image(1:28, 1:28, im, col=gray((0:255)/255))
# Encoder results
# dim(enc_output_cifra)
par(mfrow = c(2,2))
for (k in 1:4){
im<-matrix(enc_output_cifra[idx,,,k], nrow=4, ncol=4)
image(1:4, 1:4, im, col=gray((0:255)/255),
xlab = y_test_cifra[k])
}
par(mfrow = c(1,1))
save(enc_output_cifra, y_test_cifra, file=paste0("Conv_Encod_orig", paste(cifra, collapse = ""), ".RData"))
dim(enc_output_cifra) <- c(nrow(enc_output_cifra),prod(dim(enc_output_cifra)[-1]))
# Flatten array
save(enc_output_cifra, y_test_cifra, file=paste0("Conv_Encod_Flat_", paste(cifra, collapse = ""), ".RData"))
# flat file
# flat file
#enc_output_cifra_flat <- enc_output_cifra
# Flatten array
# load libraries
library(ggplot2)
library(RColorBrewer)
library(Rtsne)
library(ggrepel)
# Load Data: enc_output.cifra & y_test_cifra
# from CAE-MNIST.R script which do an autoencoder network
load("Conv_Encod_Flat_0123456789.RData")
data_to_project <- enc_output_cifra
v_labels <- as.factor(y_test_cifra)
n_v_labels <- nlevels(v_labels)
# k is the number of images to project
k <- 8000 # nrow(data_to_project)
# PCA function
plotPCA3 <- function (datos, labels, factor,title,scale,colores, size = 2, glineas = 0.25) {
data <- prcomp(datos , scale = scale)
dataDf <- data.frame(data$x)
Group <- factor
loads <- round(data$sdev^2/sum(data$sdev^2)*100,1)
# the graphic
p1 <- ggplot(dataDf,aes(x=PC1, y=PC2)) +
theme_classic() +
geom_hline(yintercept = 0, color = "gray70") +
geom_vline(xintercept = 0, color = "gray70") +
geom_point(aes(color = Group), alpha = 0.55, size = 3) +
coord_cartesian(xlim = c(min(data$x[,1])-5,max(data$x[,1])+5)) +
scale_fill_discrete(name = "")
# the graphic with ggrepel
p1 + geom_text_repel(aes(y = PC2 + 0.25, label = labels),segment.size = 0.25, size = size) +
labs(x = c(paste("PC1",loads[1],"%")),y=c(paste("PC2",loads[2],"%"))) +
ggtitle(paste("PCA based on", title, sep=" "))+
theme(plot.title = element_text(hjust = 0.5)) +
scale_color_manual(values=colores)
}
install.packages("Rtsne")
# load libraries
library(ggplot2)
library(RColorBrewer)
library(Rtsne)
library(ggrepel)
# Load Data: enc_output.cifra & y_test_cifra
# from CAE-MNIST.R script which do an autoencoder network
load("Conv_Encod_Flat_0123456789.RData")
data_to_project <- enc_output_cifra
v_labels <- as.factor(y_test_cifra)
n_v_labels <- nlevels(v_labels)
# k is the number of images to project
k <- 8000 # nrow(data_to_project)
# PCA function
plotPCA3 <- function (datos, labels, factor,title,scale,colores, size = 2, glineas = 0.25) {
data <- prcomp(datos , scale = scale)
dataDf <- data.frame(data$x)
Group <- factor
loads <- round(data$sdev^2/sum(data$sdev^2)*100,1)
# the graphic
p1 <- ggplot(dataDf,aes(x=PC1, y=PC2)) +
theme_classic() +
geom_hline(yintercept = 0, color = "gray70") +
geom_vline(xintercept = 0, color = "gray70") +
geom_point(aes(color = Group), alpha = 0.55, size = 3) +
coord_cartesian(xlim = c(min(data$x[,1])-5,max(data$x[,1])+5)) +
scale_fill_discrete(name = "")
# the graphic with ggrepel
p1 + geom_text_repel(aes(y = PC2 + 0.25, label = labels),segment.size = 0.25, size = size) +
labs(x = c(paste("PC1",loads[1],"%")),y=c(paste("PC2",loads[2],"%"))) +
ggtitle(paste("PCA based on", title, sep=" "))+
theme(plot.title = element_text(hjust = 0.5)) +
scale_color_manual(values=colores)
}
scale = FALSE
if (n_v_labels > 2) {
colores <- brewer.pal(n = n_v_labels, name = "RdBu")
} else {
colores <- c("red","blue")
}
plotPCA3(datos = data_to_project[1:k,],
labels = rep("",k),
factor = v_labels[1:k],
scale = scale,
title = paste ("last encode layer.", "# Samples:", k),
colores = colores)
## Rtsne function may take some minutes to complete...
set.seed(123456)
tsne_model_1 = Rtsne(data_to_project[1:k,],
check_duplicates=FALSE,
pca=TRUE,
perplexity=30,
theta=0.5,
dims=2)
## getting the two dimension matrix
d_tsne_1 = as.data.frame(tsne_model_1$Y)
## plotting the results without clustering
ggplot(d_tsne_1, aes(x=V1, y=V2, colour=v_labels[1:k])) +
geom_point(size=0.40) +
guides(colour=guide_legend(override.aes=list(size=6))) +
xlab("") + ylab("") +
ggtitle("t-SNE") +
theme_light(base_size=20) +
theme(axis.text.x=element_blank(),
axis.text.y=element_blank()) +
scale_color_manual(values=colores)
knitr::opts_chunk$set(echo = TRUE)
library(rstan)
library(ggplot2)
library(tidyr)
data<- read.csv("data/Norway_total_death.csv", sep = ";")
setwd("~/Documents/Utveksling/Baysiana/UPC-Final-Project-Bayesian-Analysis/Excess_death")
data<- read.csv("data/Norway_total_death.csv", sep = ";")
data<- read.csv("/Users/aurorahofman/Documents/Utveksling/Baysiana/UPC-Final-Project-Bayesian-Analysis/Aurora_testing_things/data/Norway_total_death.csv", sep = ";")
mean_norway <- as.vector(as.matrix(data)[,8])
data_2020_norway<-as.vector(as.matrix(data)[,7])
N_norway <- length(mean_norway)
data_list_norway <- list(
N = N_norway,
E = mean_norway,
O = data_2020_norway,
mu = 0,
mu2 = 0,
sigma1 = 100#,
#sigma2 = 10
)
death_norway <- stan("/Users/aurorahofman/Documents/Utveksling/Baysiana/test.stan", iter = 4000, chains = 4,
data = data_list_norway, seed = 1)
death_norway <- stan("/Users/aurorahofman/Documents/Utveksling/Baysiana/test.stan", iter = 4000, chains = 4,
data = data_list_norway, seed = 1)
death_norway <- stan("/Users/aurorahofman/Documents/Utveksling/Baysiana/test.stan", iter = 4000, chains = 4,
data = data_list_norway, seed = 1)
death_norway <- stan("/Users/aurorahofman/Documents/Utveksling/Baysiana/test.stan", iter = 4000, chains = 4,
data = data_list_norway, seed = 1)
N_norway <- length(mean_norway)
data_list_norway <- list(
N = N_norway,
E = mean_norway,
O = data_2020_norway,
mu = 0,
mu2 = 0,
#sigma1 = 100,
sigma2 = 10
)
death_norway <- stan("/Users/aurorahofman/Documents/Utveksling/Baysiana/test.stan", iter = 4000, chains = 4,
data = data_list_norway, seed = 1)
print(death_norway)
fit_norway<-summary(death_norway)
results_norway <- as.data.frame(fit_norway$summary)
CI_upper <- exp(results_norway$`97.5%`)[1:16]
CI_lower <- exp(results_norway$`2.5%`)[1:16]
theta <- exp(results_norway$mean)[1:16]
week = seq(1:16)
ggplot(data = tibble(week, CI_upper, CI_lower, theta), aes(x = week, y = theta)) + geom_point() + geom_line(lty = 2) +
geom_line(aes(week, CI_lower), col = "blue", lty = 2) +
geom_line(aes(week, CI_upper), col = "blue", lty = 2) +
ggtitle("Riskfactor for the Norway")
